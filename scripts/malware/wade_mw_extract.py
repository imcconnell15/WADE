#!/usr/bin/env python3
# WADE - Malware Extractor
# Usage examples are at the bottom of this file (search: USAGE).
import argparse, subprocess, sys, os, json, shutil, hashlib, tempfile, re, getpass, time, uuid
from pathlib import Path
from datetime import datetime, timezone

# ---------- Constants (edit to taste) ----------
DS_BASE = Path("/home/autopsy/DataSources/Hosts")
LOG_DIR = Path("/var/wade/logs/malware")
DEFAULT_ZIP_PASSWORD = "infected"
DEFAULT_SPLUNK_INDEX = "wade_malware"   # change if you insist on Wade_malware
SOURCETYPE = "wade:malware:extractor"
TOOL_NAME = "wade-mw-extract"

# ---------- Helpers ----------
def which(cmd):
    return shutil.which(cmd) is not None

def run(cmd, capture=True, check=True, text=True):
    return subprocess.run(cmd, capture_output=capture, check=check, text=text)

def ensure_dir(p: Path):
    p.mkdir(parents=True, exist_ok=True)

def now_iso():
    return datetime.now(timezone.utc).isoformat()

def hash_file(p: Path):
    digests = {"md5": hashlib.md5(), "sha1": hashlib.sha1(), "sha256": hashlib.sha256()}
    with p.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            for d in digests.values(): d.update(chunk)
    return {k: v.hexdigest() for k, v in digests.items()}

def infer_hash_algo(h):
    h = h.lower()
    if re.fullmatch(r"[0-9a-f]{32}", h): return "md5"
    if re.fullmatch(r"[0-9a-f]{40}", h): return "sha1"
    if re.fullmatch(r"[0-9a-f]{64}", h): return "sha256"
    return None

def zip_with_password(input_path: Path, out_zip: Path, password: str):
    # Prefer 7zz (AES-256). Fallback to zip -P (ZipCrypto).
    if which("7zz") or which("7z") or which("7za"):
        seven = shutil.which("7zz") or shutil.which("7z") or shutil.which("7za")
        # -tzip forces zip container, -mem=AES256 for strong crypto
        cmd = [seven, "a", "-tzip", f"-p{password}", "-mem=AES256", str(out_zip), str(input_path)]
        run(cmd)
        return {"method": "7z", "aes": True}
    elif which("zip"):
        cmd = ["zip", "-P", password, "-j", str(out_zip), str(input_path)]
        run(cmd)
        return {"method": "zip", "aes": False}
    else:
        raise RuntimeError("Neither 7z/7zz nor zip present on system")

def get_hostname_for_image(image: Path):
    # Try Dissect's target-info JSON; fallback to image stem.
    if which("target-info"):
        try:
            res = run(["target-info", "-J", str(image)])
            data = json.loads(res.stdout) if res.stdout.strip() else {}
            # very defensively try a few places
            return (data.get("hostname")
                    or data.get("system", {}).get("hostname")
                    or Path(image).stem)
        except Exception:
            return Path(image).stem
    return Path(image).stem

def extract_from_disk_by_path(image: Path, fs_path: str, outdir: Path):
    """Use Dissect target-fs cp PATH -o OUTDIR"""
    if not which("target-fs"):
        raise RuntimeError("target-fs not found in PATH (Dissect CLI)")
    ensure_dir(outdir)
    # Copy preserves filename; for single file path this is ideal.
    cmd = ["target-fs", str(image), "cp", fs_path, "-o", str(outdir)]
    run(cmd)
    # The cp output lists copies; just pick file that matches basename
    base = Path(fs_path).name
    cand = list(outdir.glob(base)) or list(outdir.glob("*"))
    if not cand:
        raise RuntimeError(f"target-fs cp produced no files for {fs_path}")
    return cand[0]

def _walk_candidates(image: Path, root_inside: str, exts: set[str] | None, limit: int):
    if not which("target-fs"):
        raise RuntimeError("target-fs not found in PATH (Dissect CLI)")
    cmd = ["target-fs", str(image), "walk", root_inside]
    res = run(cmd)
    lines = [l.strip() for l in res.stdout.splitlines() if l.strip()]
    cands = []
    for l in lines:
        # normalize Windows slashes:
        name = Path(l.replace("\\", "/")).name
        if exts:
            if not any(name.lower().endswith(e) for e in exts):
                continue
        cands.append(l)
        if len(cands) >= limit:
            break
    return cands

def extract_from_disk_by_hash(image: Path, want_hash: str, algo: str, root_inside: str, outdir: Path,
                              exts_csv: str, max_candidates: int):
    ensure_dir(outdir)
    exts = set([e.strip().lower() for e in exts_csv.split(",")]) if exts_csv else None
    paths = _walk_candidates(image, root_inside, exts, max_candidates)
    for pth in paths:
        # dump candidate to temp, hash, compare
        tmp = outdir / ("cand_" + uuid.uuid4().hex)
        # use target-fs cat -> tmp
        cmd = ["target-fs", str(image), "cat", pth]
        with tmp.open("wb") as f:
            r = subprocess.run(cmd, stdout=f, stderr=subprocess.PIPE)
        if r.returncode != 0:
            tmp.unlink(missing_ok=True)
            continue
        dig = hash_file(tmp)
        if dig.get(algo) == want_hash.lower():
            # rename to its basename
            final = outdir / Path(pth).name
            tmp.rename(final)
            return final, pth, dig
        tmp.unlink(missing_ok=True)
    return None, None, None

def vol_dump_candidates(mem: Path, outdir: Path, pid: int | None, name_sub: str | None):
    """Use Vol3 to dump candidate files or memory regions for later hashing.
       Strategy:
         - try windows.dumpfiles (file cache/shared sections)
         - if pid provided and dumpfiles too generic, try windows.memmap --dump --pid
    """
    if not which("vol") and not which("vol.py") and not which("volatility3"):
        raise RuntimeError("Volatility 3 CLI not found (vol)")
    vol = shutil.which("vol") or shutil.which("vol.py") or shutil.which("volatility3")
    ensure_dir(outdir)

    # Prefer dumpfiles (has better file artifacts)
    base_cmd = [vol, "-f", str(mem), "-o", str(outdir), "windows.dumpfiles"]
    if pid: base_cmd += ["--pid", str(pid)]
    # name filter is not consistently available; still pass if provided
    if name_sub: base_cmd += ["--name", name_sub]
    subprocess.run(base_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    # If nothing dropped, try memmap --dump (per-PID)
    if not any(outdir.iterdir()) and pid:
        mm_cmd = [vol, "-f", str(mem), "-o", str(outdir), "windows.memmap", "--dump", "--pid", str(pid)]
        subprocess.run(mm_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    dumped = [p for p in outdir.iterdir() if p.is_file()]
    return dumped

def capa_analyze(sample: Path, rules_dir: Path | None, out_json: Path):
    if not which("capa"):
        return None, "capa not found"
    cmd = ["capa", "-j", str(sample)]
    if rules_dir and rules_dir.exists():
        cmd = ["capa", "-j", "-r", str(rules_dir), str(sample)]
    res = run(cmd)
    out_json.write_text(res.stdout or "{}", encoding="utf-8")
    # light summary (count rules, ATT&CK tactics, first 10 capabilities)
    try:
        data = json.loads(res.stdout or "{}")
        caps = []
        if isinstance(data, dict) and "rules" in data:
            for rid, r in data["rules"].items():
                if r.get("meta", {}).get("name"):
                    caps.append(r["meta"]["name"])
        return {
            "cap_count": len(caps),
            "top_caps": caps[:10],
        }, None
    except Exception as e:
        return None, f"capa parse error: {e}"

def write_log(entry: dict):
    ensure_dir(LOG_DIR)
    # daily file to keep them small
    fpath = LOG_DIR / f"extract_{datetime.now().strftime('%Y%m%d')}.jsonl"
    with fpath.open("a", encoding="utf-8") as f:
        f.write(json.dumps(entry, ensure_ascii=False) + "\n")
    return str(fpath)

# ---------- Main ----------
def main():
    ap = argparse.ArgumentParser(
        description="Locate+extract from disk or memory, zip w/ password, stage in DataSources, and JSONL-log for Splunk.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    src = ap.add_argument_group("Source (pick exactly one)")
    src.add_argument("--disk-image", help="Path to E01/raw/vmdk/etc for Dissect", type=Path)
    src.add_argument("--mem-image", help="Path to memory image for Volatility 3", type=Path)
    src.add_argument("--live-path", help="Extract this path from local filesystem", type=str)

    mode = ap.add_argument_group("Locate mode (pick one)")
    mode.add_argument("--fs-path", help="Internal filepath inside DISK image (e.g., C:\\Windows\\Temp\\file.exe)")
    mode.add_argument("--hash", help="Hash (md5/sha1/sha256). For memory: we'll dump candidates and match by hash.")
    mode.add_argument("--hash-algo", choices=["md5", "sha1", "sha256"], help="Override hash algo (auto by length)")

    disk = ap.add_argument_group("Disk options")
    disk.add_argument("--search-root", default="C:\\", help="When searching by hash inside disk image, start here")
    disk.add_argument("--exts", default=".exe,.dll,.sys,.scr,.bin,.dat,.tmp", help="Comma list of extensions to consider")
    disk.add_argument("--max-candidates", type=int, default=200, help="Max walk() candidates to hash inside image")

    mem = ap.add_argument_group("Memory options")
    mem.add_argument("--pid", type=int, help="Target PID (Vol3). If absent, dump broad set and filter by hash.")
    mem.add_argument("--name-sub", help="Substring for dumpfiles name filter (if supported)")

    out = ap.add_argument_group("Output")
    out.add_argument("--password", default=DEFAULT_ZIP_PASSWORD, help="Password for ZIP")
    out.add_argument("--host", help="Override host folder under DataSources/Hosts")
    out.add_argument("--notes", help="Freeform analyst note to include in log")
    out.add_argument("--capa", action="store_true", help="Run capa against extracted binary and store JSON")
    out.add_argument("--capa-rules", type=Path, help="Optional path to capa-rules directory")

    args = ap.parse_args()

    # validate selection
    src_count = sum(1 for x in [args.disk_image, args.mem_image, args.live_path] if x)
    if src_count != 1:
        ap.error("Pick exactly ONE of --disk-image, --mem-image, or --live-path")
    mode_count = sum(1 for x in [args.fs_path, args.hash] if x)
    if args.live_path and not mode_count:
        # live path implies we already know exact path; allow no mode switches
        mode_count = 1
    if mode_count != 1:
        ap.error("Pick exactly ONE of --fs-path or --hash (live-path implies path mode)")

    # compute hash algo
    algo = args.hash_algo or (infer_hash_algo(args.hash) if args.hash else None)
    if args.hash and not algo:
        ap.error("Could not infer hash algorithm from --hash; specify --hash-algo")

    started = now_iso()
    actor = getpass.getuser()
    session_id = uuid.uuid4().hex[:12]
    temp_root = Path(tempfile.mkdtemp(prefix=f"wme_{session_id}_"))
    extracted_file = None
    internal_path = None
    hashes = None
    src_type = "live" if args.live_path else ("memory" if args.mem_image else "disk")
    capa_summary = None
    capa_err = None
    zip_meta = None
    host = args.host or "unknown"

    try:
        if src_type == "disk":
            image = args.disk_image
            if not image.exists():
                raise RuntimeError(f"Disk image not found: {image}")
            host = args.host or get_hostname_for_image(image)
            work = temp_root / "disk_extract"
            ensure_dir(work)

            if args.fs_path:
                extracted_file = extract_from_disk_by_path(image, args.fs_path, work)
                internal_path = args.fs_path
                hashes = hash_file(extracted_file)
            else:
                # by hash
                found, intp, dig = extract_from_disk_by_hash(
                    image, args.hash.lower(), algo, args.search_root, work, args.exts, args.max_candidates
                )
                if not found:
                    raise RuntimeError("No match found inside image for provided hash")
                extracted_file, internal_path, hashes = found, intp, dig

        elif src_type == "memory":
            mem = args.mem_image
            if not mem.exists():
                raise RuntimeError(f"Memory image not found: {mem}")
            work = temp_root / "mem_extract"
            ensure_dir(work)
            candidates = vol_dump_candidates(mem, work, args.pid, args.name_sub)
            if not candidates:
                raise RuntimeError("Volatility produced no candidate dumps")
            # path mode is not very meaningful in memory; hash matching is the reliable route
            if args.hash:
                matched = None
                for c in candidates:
                    dig = hash_file(c)
                    if dig.get(algo) == args.hash.lower():
                        extracted_file = c
                        hashes = dig
                        internal_path = c.name
                        matched = True
                        break
                if not matched:
                    raise RuntimeError("No candidate dump matched the provided hash")
            else:
                # take first candidate and proceed
                extracted_file = candidates[0]
                hashes = hash_file(extracted_file)
                internal_path = extracted_file.name

        else:  # live
            p = Path(args.live_path)
            if not p.exists():
                raise RuntimeError(f"Live path does not exist: {p}")
            host = args.host or os.uname().nodename
            work = temp_root / "live_extract"; ensure_dir(work)
            extracted_file = work / p.name
            shutil.copy2(p, extracted_file)
            hashes = hash_file(extracted_file)
            internal_path = str(p)

        # Run capa (optional, best-effort on PE/ELF; ignore errors)
        capa_json_path = None
        if args.capa:
            capa_json_path = temp_root / (extracted_file.name + ".capa.json")
            capa_summary, capa_err = capa_analyze(extracted_file, args.capa_rules, capa_json_path)

        # Stage to DataSources
        ts = datetime.now().strftime("%Y-%m-%d_%H%M%S")
        dest_dir = DS_BASE / host / "malware" / ts
        ensure_dir(dest_dir)
        # zip artifact
        out_zip = dest_dir / (extracted_file.name + ".zip")
        zip_meta = zip_with_password(extracted_file, out_zip, args.password)

        # copy capa JSON if created
        if args.capa and capa_json_path and capa_json_path.exists():
            shutil.copy2(capa_json_path, dest_dir / capa_json_path.name)

        # manifest
        manifest = {
            "sample": extracted_file.name,
            "zip": out_zip.name,
            "internal_path": internal_path,
            "hashes": hashes,
            "created_utc": now_iso(),
            "password_hint": "provided by operator",  # don't leak the password itself
            "capa_json": (capa_json_path.name if (capa_json_path and capa_json_path.exists()) else None),
        }
        (dest_dir / "manifest.json").write_text(json.dumps(manifest, indent=2), encoding="utf-8")

        # Splunk log
        log_entry = {
            "time": now_iso(),
            "tool": TOOL_NAME,
            "actor": actor,
            "session": session_id,
            "index": DEFAULT_SPLUNK_INDEX,
            "sourcetype": SOURCETYPE,
            "source_type": src_type,                # disk|memory|live
            "disk_image": str(args.disk_image) if args.disk_image else None,
            "mem_image": str(args.mem_image) if args.mem_image else None,
            "live_path": args.live_path if args.live_path else None,
            "host": host,
            "internal_path": internal_path,
            "output_zip": str(out_zip),
            "zip_method": zip_meta,
            "hashes": hashes,
            "notes": args.notes or "",
            "capa_summary": capa_summary,
            "capa_error": capa_err,
            "started_utc": started,
            "ended_utc": now_iso(),
            "status": "success",
        }
        log_file = write_log(log_entry)

        print(f"[OK] Staged: {out_zip}")
        print(f"     Host:   {host}")
        print(f"     Log:    {log_file}")
        if capa_summary:
            print(f"     capa:   {capa_summary['cap_count']} caps; e.g. {', '.join(capa_summary['top_caps'])}")
        return 0

    except Exception as e:
        err_entry = {
            "time": now_iso(),
            "tool": TOOL_NAME,
            "actor": actor,
            "session": session_id,
            "index": DEFAULT_SPLUNK_INDEX,
            "sourcetype": SOURCETYPE,
            "source_type": src_type,
            "error": str(e),
            "started_utc": started,
            "ended_utc": now_iso(),
            "status": "error",
        }
        write_log(err_entry)
        print(f"[ERR] {e}", file=sys.stderr)
        return 2
    finally:
        shutil.rmtree(temp_root, ignore_errors=True)

if __name__ == "__main__":
    sys.exit(main())

# ------------------------- USAGE -------------------------
# Disk by path:
#   wade-mw-extract --disk-image /path/host.E01 --fs-path "C:\\Users\\Public\\evil.exe"
#
# Disk by hash (limit search scope for speed):
#   wade-mw-extract --disk-image /path/host.E01 --hash 5f16... --search-root "C:\Users\Public" --exts ".exe,.dll" --host MYHOST --capa --capa-rules /opt/capa-rules
#
# Memory (Windows) by hash (with PID hint):
#   wade-mw-extract --mem-image /path/win.vmem --pid 4242 --hash e3b0... --capa
#
# Live path (server local file):
#   wade-mw-extract --live-path /tmp/suspicious.bin --capa
